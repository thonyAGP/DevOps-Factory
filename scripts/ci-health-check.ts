/**
 * ci-health-check.ts
 *
 * Monitors CI status across all repos with hasCI: true.
 * Creates GitHub Issues on failure, auto-closes on recovery.
 * Extracts failed job logs for diagnostic context.
 *
 * Run: pnpm ci-health
 * Cron: every 2h via GitHub Actions
 */

import { execSync } from 'node:child_process';
import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { KNOWN_PROJECTS, type ProjectConfig } from '../factory.config.js';

interface WorkflowRun {
  id: number;
  conclusion: string | null;
  status: string;
  name: string;
  html_url: string;
  created_at: string;
  head_branch: string;
}

interface CICheckResult {
  project: ProjectConfig;
  status: 'pass' | 'fail' | 'pending' | 'no_runs';
  run: WorkflowRun | null;
  failedLogs: string;
}

interface ExistingIssue {
  number: number;
  title: string;
}

const LABEL = 'ci-failure';
const MAX_LOG_LENGTH = 2000;
const SELF_HEAL_COOLDOWN_MS = 4 * 60 * 60 * 1000; // 4h between self-heal attempts per repo
const FACTORY_COOLDOWN_MS = 24 * 60 * 60 * 1000; // 24h for DevOps-Factory (avoid loops)
const FACTORY_REPO = 'thonyAGP/DevOps-Factory';

const sh = (cmd: string): string => {
  try {
    return execSync(cmd, { encoding: 'utf-8', timeout: 30000 }).trim();
  } catch {
    return '';
  }
};

const getLatestRun = (repo: string): WorkflowRun | null => {
  const result = sh(
    `gh api "repos/${repo}/actions/runs?per_page=1&status=completed" --jq ".workflow_runs[0] | {id, conclusion, status, name, html_url, created_at, head_branch}"`
  );
  if (!result || result === 'null') return null;
  try {
    return JSON.parse(result) as WorkflowRun;
  } catch {
    return null;
  }
};

const getFailedLogs = (repo: string, runId: number): string => {
  const logs = sh(`gh run view ${runId} --repo ${repo} --log-failed 2>&1 | tail -80`);
  if (!logs) return 'No failed logs available.';
  return logs.length > MAX_LOG_LENGTH ? `...${logs.slice(-MAX_LOG_LENGTH)}` : logs;
};

const getExistingIssues = (factoryRepo: string): ExistingIssue[] => {
  const result = sh(
    `gh issue list --repo ${factoryRepo} --label "${LABEL}" --state open --json number,title --jq "[.[] | {number, title}]"`
  );
  try {
    return JSON.parse(result || '[]') as ExistingIssue[];
  } catch {
    return [];
  }
};

const issueExistsForProject = (
  issues: ExistingIssue[],
  projectName: string
): ExistingIssue | null => {
  return issues.find((i) => i.title.includes(projectName)) ?? null;
};

const createIssue = (factoryRepo: string, result: CICheckResult): void => {
  const { project, run, failedLogs } = result;
  if (!run) return;

  const title = `CI FAILURE: ${project.name}`;
  const body = [
    '## CI Failure Detected',
    '',
    `| Field | Value |`,
    `|-------|-------|`,
    `| **Repo** | [${project.repo}](https://github.com/${project.repo}) |`,
    `| **Workflow** | ${run.name} |`,
    `| **Branch** | \`${run.head_branch}\` |`,
    `| **Run** | [View run](${run.html_url}) |`,
    `| **Failed at** | ${run.created_at} |`,
    `| **Stack** | ${project.stack} |`,
    '',
    '### Failed Logs (last 80 lines)',
    '',
    '```',
    failedLogs,
    '```',
    '',
    '---',
    '*Auto-generated by DevOps Factory CI Health Check. This issue will auto-close when CI passes.*',
  ].join('\n');

  try {
    const tmpFile = '/tmp/ci-health-body.md';
    execSync(`cat > ${tmpFile} << 'CIEOF'\n${body}\nCIEOF`, { encoding: 'utf-8' });
    execSync(
      `gh issue create --repo ${factoryRepo} --title "${title}" --body-file ${tmpFile} --label "${LABEL}"`,
      { encoding: 'utf-8', stdio: 'inherit' }
    );
    console.log(`  [CREATED] Issue for ${project.name}`);
  } catch (e) {
    console.error(`  [ERROR] Failed to create issue for ${project.name}:`, e);
  }
};

const closeIssue = (factoryRepo: string, issue: ExistingIssue, projectName: string): void => {
  try {
    execSync(
      `gh issue close ${issue.number} --repo ${factoryRepo} --comment "CI recovered on ${projectName}. Auto-closing."`,
      { encoding: 'utf-8', stdio: 'inherit' }
    );
    console.log(`  [CLOSED] Issue #${issue.number} - ${projectName} recovered`);
  } catch (e) {
    console.error(`  [ERROR] Failed to close issue #${issue.number}:`, e);
  }
};

const COOLDOWN_PATH = 'data/self-heal-cooldowns.json';

type CooldownMap = Record<string, number>;

const loadCooldowns = (): CooldownMap => {
  if (!existsSync(COOLDOWN_PATH)) return {};
  try {
    return JSON.parse(readFileSync(COOLDOWN_PATH, 'utf-8')) as CooldownMap;
  } catch {
    return {};
  }
};

const saveCooldown = (repo: string): void => {
  const cooldowns = loadCooldowns();
  cooldowns[repo] = Date.now();
  writeFileSync(COOLDOWN_PATH, JSON.stringify(cooldowns, null, 2));
};

const getLastSelfHealForRepo = (repo: string): number => {
  const cooldowns = loadCooldowns();
  return cooldowns[repo] ?? 0;
};

const hasOpenAiFixPR = (repo: string): boolean => {
  const result = sh(
    `gh pr list --repo ${repo} --head "ai-fix/" --state open --json number --jq "length"`
  );
  return parseInt(result || '0', 10) > 0;
};

const hasRecentAiFixMerge = (repo: string, windowMs: number): boolean => {
  const result = sh(
    `gh pr list --repo ${repo} --search "head:ai-fix/ is:merged" --state merged --json mergedAt --jq ".[0].mergedAt" 2>/dev/null`
  );
  if (!result || result === 'null') return false;
  const mergedAt = new Date(result).getTime();
  return Date.now() - mergedAt < windowMs;
};

const triggerSelfHeal = (factoryRepo: string, result: CICheckResult): void => {
  const { project, run } = result;
  if (!run) return;

  // Guard: only self-heal on default branch (main/master)
  const defaultBranch = sh(`gh api "repos/${project.repo}" --jq ".default_branch" 2>/dev/null`);
  if (defaultBranch && run.head_branch !== defaultBranch) {
    console.log(
      `  [SKIP HEAL] ${project.name}: failure on ${run.head_branch}, not ${defaultBranch}`
    );
    return;
  }

  // Guard: don't self-heal failures on ai-fix branches (avoid loops)
  if (run.head_branch.startsWith('ai-fix/')) {
    console.log(`  [SKIP HEAL] ${project.name}: failure on ai-fix branch, skip`);
    return;
  }

  // Guard: don't trigger if there's already an open ai-fix PR
  if (hasOpenAiFixPR(project.repo)) {
    console.log(`  [SKIP HEAL] ${project.name}: open ai-fix PR exists`);
    return;
  }

  // Guard: don't trigger if an ai-fix PR was merged recently (CI may still be cascading)
  const AI_FIX_MERGE_WINDOW_MS = 2 * 60 * 60 * 1000; // 2h
  if (hasRecentAiFixMerge(project.repo, AI_FIX_MERGE_WINDOW_MS)) {
    console.log(`  [SKIP HEAL] ${project.name}: ai-fix PR merged <2h ago, waiting for CI cascade`);
    return;
  }

  // Guard: per-repo cooldown (24h for factory, 4h for others)
  const isFactory = project.repo === FACTORY_REPO;
  const cooldown = isFactory ? FACTORY_COOLDOWN_MS : SELF_HEAL_COOLDOWN_MS;
  const cooldownLabel = isFactory ? '24h' : '4h';
  const lastAttempt = getLastSelfHealForRepo(project.repo);
  if (Date.now() - lastAttempt < cooldown) {
    const hoursAgo = ((Date.now() - lastAttempt) / 3600000).toFixed(1);
    console.log(
      `  [SKIP HEAL] ${project.name}: last attempt ${hoursAgo}h ago (cooldown ${cooldownLabel})`
    );
    return;
  }

  // Trigger self-heal workflow + record cooldown
  try {
    execSync(
      `gh workflow run self-heal.yml --repo ${factoryRepo} -f repo="${project.repo}" -f run_id="${run.id}"`,
      { encoding: 'utf-8', timeout: 15000 }
    );
    saveCooldown(project.repo);
    console.log(`  [HEAL] Triggered self-heal for ${project.name} (run ${run.id})`);
  } catch (e) {
    console.error(`  [ERROR] Failed to trigger self-heal for ${project.name}:`, e);
  }
};

const updateIssue = (factoryRepo: string, issue: ExistingIssue, result: CICheckResult): void => {
  const { project, run } = result;
  if (!run) return;

  const comment = `Still failing at ${new Date().toISOString()}\n- Run: [${run.name}](${run.html_url})\n- Branch: \`${run.head_branch}\``;
  try {
    execSync(`gh issue comment ${issue.number} --repo ${factoryRepo} --body "${comment}"`, {
      encoding: 'utf-8',
      stdio: 'pipe',
    });
    console.log(`  [UPDATED] Issue #${issue.number} - ${project.name} still failing`);
  } catch {
    // Silent - comment update is best effort
  }
};

const main = () => {
  const factoryRepo = process.env.GITHUB_REPOSITORY ?? 'thonyAGP/DevOps-Factory';
  const ciProjects = KNOWN_PROJECTS.filter((p) => p.hasCI);

  console.log(`\nCI Health Check - ${new Date().toISOString()}`);
  console.log(`Checking ${ciProjects.length} repos with CI enabled\n`);

  const existingIssues = getExistingIssues(factoryRepo);
  console.log(`Open ci-failure issues: ${existingIssues.length}\n`);

  const results: CICheckResult[] = [];

  for (const project of ciProjects) {
    process.stdout.write(`Checking ${project.name}... `);
    const run = getLatestRun(project.repo);

    if (!run) {
      console.log('no runs found');
      results.push({ project, status: 'no_runs', run: null, failedLogs: '' });
      continue;
    }

    if (run.conclusion === 'success') {
      console.log('PASS');
      results.push({ project, status: 'pass', run, failedLogs: '' });
    } else {
      const failedLogs = getFailedLogs(project.repo, run.id);
      console.log(`FAIL (${run.conclusion})`);
      results.push({ project, status: 'fail', run, failedLogs });
    }
  }

  // Process results: create/update/close issues
  console.log('\n--- Issue Management ---\n');

  let created = 0;
  let closed = 0;
  let updated = 0;

  for (const result of results) {
    const existing = issueExistsForProject(existingIssues, result.project.name);

    if (result.status === 'fail') {
      if (existing) {
        updateIssue(factoryRepo, existing, result);
        updated++;
      } else {
        createIssue(factoryRepo, result);
        created++;
      }
      // Auto-trigger self-heal for enabled repos
      if (result.project.hasSelfHealing) {
        triggerSelfHeal(factoryRepo, result);
      }
    } else if (result.status === 'pass' && existing) {
      closeIssue(factoryRepo, existing, result.project.name);
      closed++;
    }
  }

  // Summary
  const passing = results.filter((r) => r.status === 'pass').length;
  const failing = results.filter((r) => r.status === 'fail').length;
  const noRuns = results.filter((r) => r.status === 'no_runs').length;

  console.log('\n--- Summary ---');
  console.log(`Passing: ${passing}/${ciProjects.length}`);
  console.log(`Failing: ${failing}/${ciProjects.length}`);
  if (noRuns > 0) console.log(`No runs: ${noRuns}`);
  console.log(`Issues: ${created} created, ${updated} updated, ${closed} closed`);
  console.log('');

  if (failing > 0) {
    console.log(`WARNING: ${failing} CI(s) failing - issues created/updated above`);
  }
};

main();
