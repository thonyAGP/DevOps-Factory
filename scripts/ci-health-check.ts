/**
 * ci-health-check.ts
 *
 * Monitors CI status across all repos with hasCI: true.
 * Creates GitHub Issues on failure, auto-closes on recovery.
 * Extracts failed job logs for diagnostic context.
 *
 * Run: pnpm ci-health
 * Cron: every 2h via GitHub Actions
 */

import { execSync } from 'node:child_process';
import { readFileSync, writeFileSync, existsSync, unlinkSync } from 'node:fs';
import { KNOWN_PROJECTS, type ProjectConfig } from '../factory.config.js';
import { logActivity, type ActivityStatus } from './activity-logger.js';

interface WorkflowRun {
  id: number;
  conclusion: string | null;
  status: string;
  name: string;
  html_url: string;
  created_at: string;
  head_branch: string;
}

interface CICheckResult {
  project: ProjectConfig;
  status: 'pass' | 'fail' | 'pending' | 'no_runs';
  run: WorkflowRun | null;
  failedLogs: string;
}

interface ExistingIssue {
  number: number;
  title: string;
}

const LABEL = 'ci-failure';
const ESCALATION_LABEL = 'escalation';
const MAX_LOG_LENGTH = 2000;
const SELF_HEAL_COOLDOWN_MS = 4 * 60 * 60 * 1000; // 4h between self-heal attempts per repo
const FACTORY_COOLDOWN_MS = 24 * 60 * 60 * 1000; // 24h for DevOps-Factory (avoid loops)
const FACTORY_REPO = 'thonyAGP/DevOps-Factory';
const ESCALATION_PATH = 'data/escalation-tracker.json';
const ESCALATION_THRESHOLD = 3; // consecutive failures before escalation

const sh = (cmd: string): string => {
  try {
    return execSync(cmd, { encoding: 'utf-8', timeout: 30000 }).trim();
  } catch {
    return '';
  }
};

const getDefaultBranch = (repo: string): string => {
  return sh(`gh api "repos/${repo}" --jq ".default_branch"`) || 'main';
};

const getLatestCIRun = (
  repo: string,
  ciWorkflow: string = 'ci.yml',
  branch?: string
): WorkflowRun | null => {
  // Filter by CI workflow + default branch to avoid ai-fix branch runs masking real failures
  const branchFilter = branch ? `&branch=${branch}` : '';
  const result = sh(
    `gh api "repos/${repo}/actions/workflows/${ciWorkflow}/runs?per_page=1&status=completed${branchFilter}" --jq ".workflow_runs[0] | {id, conclusion, status, name, html_url, created_at, head_branch}"`
  );
  if (!result || result === 'null') return null;
  try {
    return JSON.parse(result) as WorkflowRun;
  } catch {
    return null;
  }
};

const getFailedLogs = (repo: string, runId: number): string => {
  const logs = sh(`gh run view ${runId} --repo ${repo} --log-failed 2>&1 | tail -80`);
  if (!logs) return 'No failed logs available.';
  return logs.length > MAX_LOG_LENGTH ? `...${logs.slice(-MAX_LOG_LENGTH)}` : logs;
};

const getExistingIssues = (factoryRepo: string): ExistingIssue[] => {
  const result = sh(
    `gh issue list --repo ${factoryRepo} --label "${LABEL}" --state open --json number,title --jq "[.[] | {number, title}]"`
  );
  try {
    return JSON.parse(result || '[]') as ExistingIssue[];
  } catch {
    return [];
  }
};

const issueExistsForProject = (
  issues: ExistingIssue[],
  projectName: string
): ExistingIssue | null => {
  return issues.find((i) => i.title.includes(projectName)) ?? null;
};

const createIssue = (factoryRepo: string, result: CICheckResult): void => {
  const { project, run, failedLogs } = result;
  if (!run) return;

  const title = `CI FAILURE: ${project.name}`;
  const body = [
    '## CI Failure Detected',
    '',
    `| Field | Value |`,
    `|-------|-------|`,
    `| **Repo** | [${project.repo}](https://github.com/${project.repo}) |`,
    `| **Workflow** | ${run.name} |`,
    `| **Branch** | \`${run.head_branch}\` |`,
    `| **Run** | [View run](${run.html_url}) |`,
    `| **Failed at** | ${run.created_at} |`,
    `| **Stack** | ${project.stack} |`,
    '',
    '### Failed Logs (last 80 lines)',
    '',
    '```',
    failedLogs,
    '```',
    '',
    '---',
    '*Auto-generated by DevOps Factory CI Health Check. This issue will auto-close when CI passes.*',
  ].join('\n');

  try {
    const tmpFile = '/tmp/ci-health-body.md';
    execSync(`cat > ${tmpFile} << 'CIEOF'\n${body}\nCIEOF`, { encoding: 'utf-8' });
    execSync(
      `gh issue create --repo ${factoryRepo} --title "${title}" --body-file ${tmpFile} --label "${LABEL}"`,
      { encoding: 'utf-8', stdio: 'inherit' }
    );
    console.log(`  [CREATED] Issue for ${project.name}`);
    logActivity(
      'ci-health-check',
      'issue-created',
      `CI failure issue created`,
      'warning',
      project.name
    );
  } catch (e) {
    console.error(`  [ERROR] Failed to create issue for ${project.name}:`, e);
    logActivity(
      'ci-health-check',
      'issue-create-failed',
      `Failed to create CI failure issue`,
      'error',
      project.name
    );
  }
};

const closeIssue = (factoryRepo: string, issue: ExistingIssue, projectName: string): void => {
  try {
    execSync(
      `gh issue close ${issue.number} --repo ${factoryRepo} --comment "CI recovered on ${projectName}. Auto-closing."`,
      { encoding: 'utf-8', stdio: 'inherit' }
    );
    console.log(`  [CLOSED] Issue #${issue.number} - ${projectName} recovered`);
    logActivity(
      'ci-health-check',
      'issue-closed',
      `CI recovered, issue #${issue.number} closed`,
      'success',
      projectName
    );
  } catch (e) {
    console.error(`  [ERROR] Failed to close issue #${issue.number}:`, e);
  }
};

// --- Escalation tracking ---

interface EscalationEntry {
  consecutiveFailures: number;
  lastFailure: string;
  escalated: boolean;
}

type EscalationMap = Record<string, EscalationEntry>;

const loadEscalation = (): EscalationMap => {
  if (!existsSync(ESCALATION_PATH)) return {};
  try {
    return JSON.parse(readFileSync(ESCALATION_PATH, 'utf-8')) as EscalationMap;
  } catch {
    return {};
  }
};

const saveEscalation = (data: EscalationMap): void => {
  writeFileSync(ESCALATION_PATH, JSON.stringify(data, null, 2));
};

const trackFailure = (factoryRepo: string, result: CICheckResult): void => {
  const tracker = loadEscalation();
  const key = result.project.repo;

  if (result.status === 'pass') {
    if (tracker[key]) {
      delete tracker[key];
      saveEscalation(tracker);
    }
    return;
  }

  if (result.status !== 'fail') return;

  const entry = tracker[key] ?? { consecutiveFailures: 0, lastFailure: '', escalated: false };
  entry.consecutiveFailures++;
  entry.lastFailure = new Date().toISOString();
  tracker[key] = entry;
  saveEscalation(tracker);

  if (entry.consecutiveFailures >= ESCALATION_THRESHOLD && !entry.escalated) {
    console.log(
      `  [ESCALATION] ${result.project.name}: ${entry.consecutiveFailures} consecutive failures`
    );
    logActivity(
      'ci-health-check',
      'escalation',
      `${entry.consecutiveFailures} consecutive CI failures`,
      'error',
      result.project.name
    );
    const title = `ESCALATION: ${result.project.name} - ${entry.consecutiveFailures} consecutive CI failures`;
    const body = [
      '## Persistent CI Failure - Escalation',
      '',
      `**${result.project.name}** has failed CI **${entry.consecutiveFailures} times consecutively**.`,
      'Self-heal has been unable to fix this issue automatically.',
      '',
      `| Field | Value |`,
      `|-------|-------|`,
      `| **Repo** | [${result.project.repo}](https://github.com/${result.project.repo}) |`,
      `| **Consecutive failures** | ${entry.consecutiveFailures} |`,
      `| **Latest run** | [View run](${result.run?.html_url}) |`,
      `| **Since** | ${entry.lastFailure} |`,
      '',
      '### Action required',
      'This failure requires **manual investigation**. Self-heal has exhausted its capabilities.',
      '',
      '---',
      '*Auto-generated by CI Health Check escalation system*',
    ].join('\n');

    sh(
      `gh label create "${ESCALATION_LABEL}" --repo ${factoryRepo} --color "b60205" --description "Persistent failure requiring manual intervention" --force`
    );
    const tmpFile = `${process.env.RUNNER_TEMP || '/tmp'}/escalation-body.md`;
    writeFileSync(tmpFile, body);
    try {
      execSync(
        `gh issue create --repo ${factoryRepo} --title "${title}" --body-file ${tmpFile} --label "${ESCALATION_LABEL}"`,
        { encoding: 'utf-8', stdio: 'inherit' }
      );
    } catch {
      /* best effort */
    }
    try {
      unlinkSync(tmpFile);
    } catch {
      /* ignore */
    }

    entry.escalated = true;
    tracker[key] = entry;
    saveEscalation(tracker);
  }
};

// --- Cooldown tracking ---

const COOLDOWN_PATH = 'data/self-heal-cooldowns.json';

type CooldownMap = Record<string, number>;

const loadCooldowns = (): CooldownMap => {
  if (!existsSync(COOLDOWN_PATH)) return {};
  try {
    return JSON.parse(readFileSync(COOLDOWN_PATH, 'utf-8')) as CooldownMap;
  } catch {
    return {};
  }
};

const saveCooldown = (repo: string): void => {
  const cooldowns = loadCooldowns();
  cooldowns[repo] = Date.now();
  writeFileSync(COOLDOWN_PATH, JSON.stringify(cooldowns, null, 2));
};

const getLastSelfHealForRepo = (repo: string): number => {
  // Local file: works within same CI run (multi-repo dedup)
  const cooldowns = loadCooldowns();
  const localTs = cooldowns[repo] ?? 0;
  if (localTs > 0) return localTs;

  // API fallback: check most recent ai-fix PR (any state) on target repo
  // Persists across CI runs since it queries GitHub, not local filesystem
  const prDate = sh(
    `gh pr list --repo ${repo} --search "head:ai-fix/" --state all --limit 1 --json createdAt --jq ".[0].createdAt" 2>/dev/null`
  );
  if (prDate && prDate !== 'null' && prDate !== '') {
    return new Date(prDate).getTime();
  }

  return 0;
};

const STALE_PR_MS = 48 * 60 * 60 * 1000; // 48h

const prCIFailed = (repo: string, prNumber: number): boolean => {
  const result = sh(
    `gh pr checks ${prNumber} --repo ${repo} --json conclusion --jq "[.[] | select(.conclusion == \\"failure\\")] | length" 2>/dev/null`
  );
  return parseInt(result || '0', 10) > 0;
};

const hasOpenAiFixPR = (repo: string): boolean => {
  const result = sh(
    `gh pr list --repo ${repo} --head "ai-fix/" --state open --json number,createdAt --jq "[.[] | {number, createdAt}]"`
  );
  let prs: Array<{ number: number; createdAt: string }>;
  try {
    prs = JSON.parse(result || '[]') as Array<{ number: number; createdAt: string }>;
  } catch {
    return false;
  }
  if (prs.length === 0) return false;

  for (const pr of prs) {
    const age = Date.now() - new Date(pr.createdAt).getTime();

    // Close PRs whose CI has failed (fix didn't work)
    if (prCIFailed(repo, pr.number)) {
      console.log(`  [CI FAILED] Closing ai-fix PR #${pr.number} on ${repo} (fix didn't work)`);
      sh(
        `gh pr close ${pr.number} --repo ${repo} --comment "Auto-closing: CI failed on this fix PR. Self-heal will retry with fresh context."`
      );
      continue;
    }

    // Close stale PRs (>48h open = abandoned)
    if (age > STALE_PR_MS) {
      console.log(
        `  [STALE] Closing abandoned ai-fix PR #${pr.number} on ${repo} (${Math.round(age / 3600000)}h old)`
      );
      sh(
        `gh pr close ${pr.number} --repo ${repo} --comment "Auto-closing stale ai-fix PR (>48h). Self-heal will retry."`
      );
    }
  }

  // Re-check after closing
  const freshResult = sh(
    `gh pr list --repo ${repo} --head "ai-fix/" --state open --json number --jq "length"`
  );
  return parseInt(freshResult || '0', 10) > 0;
};

const hasRecentAiFixMerge = (repo: string, windowMs: number): boolean => {
  const result = sh(
    `gh pr list --repo ${repo} --search "head:ai-fix/ is:merged" --state merged --json mergedAt --jq ".[0].mergedAt" 2>/dev/null`
  );
  if (!result || result === 'null') return false;
  const mergedAt = new Date(result).getTime();
  return Date.now() - mergedAt < windowMs;
};

const triggerSelfHeal = (factoryRepo: string, result: CICheckResult): void => {
  const { project, run } = result;
  if (!run) return;

  // Guard: don't self-heal failures on ai-fix branches (belt-and-suspenders, main filter is in getLatestCIRun)
  if (run.head_branch.startsWith('ai-fix/')) {
    console.log(`  [SKIP HEAL] ${project.name}: failure on ai-fix branch, skip`);
    return;
  }

  // Guard: don't trigger if there's already an open ai-fix PR
  if (hasOpenAiFixPR(project.repo)) {
    console.log(`  [SKIP HEAL] ${project.name}: open ai-fix PR exists`);
    return;
  }

  // Guard: don't trigger if an ai-fix PR was merged recently (CI may still be cascading)
  const AI_FIX_MERGE_WINDOW_MS = 2 * 60 * 60 * 1000; // 2h
  if (hasRecentAiFixMerge(project.repo, AI_FIX_MERGE_WINDOW_MS)) {
    console.log(`  [SKIP HEAL] ${project.name}: ai-fix PR merged <2h ago, waiting for CI cascade`);
    return;
  }

  // Guard: per-repo cooldown (24h for factory, 4h for others)
  const isFactory = project.repo === FACTORY_REPO;
  const cooldown = isFactory ? FACTORY_COOLDOWN_MS : SELF_HEAL_COOLDOWN_MS;
  const cooldownLabel = isFactory ? '24h' : '4h';
  const lastAttempt = getLastSelfHealForRepo(project.repo);
  if (Date.now() - lastAttempt < cooldown) {
    const hoursAgo = ((Date.now() - lastAttempt) / 3600000).toFixed(1);
    console.log(
      `  [SKIP HEAL] ${project.name}: last attempt ${hoursAgo}h ago (cooldown ${cooldownLabel})`
    );
    return;
  }

  // Trigger self-heal workflow + record cooldown
  try {
    execSync(
      `gh workflow run self-heal.yml --repo ${factoryRepo} -f repo="${project.repo}" -f run_id="${run.id}"`,
      { encoding: 'utf-8', timeout: 15000 }
    );
    saveCooldown(project.repo);
    console.log(`  [HEAL] Triggered self-heal for ${project.name} (run ${run.id})`);
    logActivity(
      'ci-health-check',
      'self-heal-triggered',
      `Self-heal dispatched (run ${run.id})`,
      'warning',
      project.name
    );
  } catch (e) {
    console.error(`  [ERROR] Failed to trigger self-heal for ${project.name}:`, e);
    logActivity(
      'ci-health-check',
      'self-heal-failed',
      `Failed to trigger self-heal`,
      'error',
      project.name
    );
  }
};

const updateIssue = (factoryRepo: string, issue: ExistingIssue, result: CICheckResult): void => {
  const { project, run } = result;
  if (!run) return;

  const comment = `Still failing at ${new Date().toISOString()}\n- Run: [${run.name}](${run.html_url})\n- Branch: \`${run.head_branch}\``;
  try {
    execSync(`gh issue comment ${issue.number} --repo ${factoryRepo} --body "${comment}"`, {
      encoding: 'utf-8',
      stdio: 'pipe',
    });
    console.log(`  [UPDATED] Issue #${issue.number} - ${project.name} still failing`);
  } catch {
    // Silent - comment update is best effort
  }
};

const main = () => {
  const factoryRepo = process.env.GITHUB_REPOSITORY ?? 'thonyAGP/DevOps-Factory';
  const ciProjects = KNOWN_PROJECTS.filter((p) => p.hasCI);

  console.log(`\nCI Health Check - ${new Date().toISOString()}`);
  console.log(`Checking ${ciProjects.length} repos with CI enabled\n`);

  const existingIssues = getExistingIssues(factoryRepo);
  console.log(`Open ci-failure issues: ${existingIssues.length}\n`);

  const results: CICheckResult[] = [];

  for (const project of ciProjects) {
    process.stdout.write(`Checking ${project.name}... `);
    const defaultBranch = getDefaultBranch(project.repo);
    const run = getLatestCIRun(project.repo, project.ciWorkflow, defaultBranch);

    if (!run) {
      console.log('no runs found');
      results.push({ project, status: 'no_runs', run: null, failedLogs: '' });
      continue;
    }

    if (run.conclusion === 'success') {
      console.log('PASS');
      results.push({ project, status: 'pass', run, failedLogs: '' });
    } else {
      const failedLogs = getFailedLogs(project.repo, run.id);
      console.log(`FAIL (${run.conclusion})`);
      results.push({ project, status: 'fail', run, failedLogs });
    }
  }

  // Process results: create/update/close issues
  console.log('\n--- Issue Management ---\n');

  let created = 0;
  let closed = 0;
  let updated = 0;

  for (const result of results) {
    const existing = issueExistsForProject(existingIssues, result.project.name);

    // Track consecutive failures for escalation
    trackFailure(factoryRepo, result);

    if (result.status === 'fail') {
      if (existing) {
        updateIssue(factoryRepo, existing, result);
        updated++;
      } else {
        createIssue(factoryRepo, result);
        created++;
      }
      // Auto-trigger self-heal for enabled repos
      if (result.project.hasSelfHealing) {
        triggerSelfHeal(factoryRepo, result);
      }
    } else if (result.status === 'pass' && existing) {
      closeIssue(factoryRepo, existing, result.project.name);
      closed++;
    }
  }

  // Summary
  const passing = results.filter((r) => r.status === 'pass').length;
  const failing = results.filter((r) => r.status === 'fail').length;
  const noRuns = results.filter((r) => r.status === 'no_runs').length;

  console.log('\n--- Summary ---');
  console.log(`Passing: ${passing}/${ciProjects.length}`);
  console.log(`Failing: ${failing}/${ciProjects.length}`);
  if (noRuns > 0) console.log(`No runs: ${noRuns}`);
  console.log(`Issues: ${created} created, ${updated} updated, ${closed} closed`);
  console.log('');

  const summaryStatus: ActivityStatus = failing > 0 ? 'warning' : 'success';
  logActivity(
    'ci-health-check',
    'check-complete',
    `${passing}/${ciProjects.length} passing, ${failing} failing. Issues: ${created} created, ${closed} closed`,
    summaryStatus
  );

  if (failing > 0) {
    console.log(`WARNING: ${failing} CI(s) failing - issues created/updated above`);
  }
};

main();
