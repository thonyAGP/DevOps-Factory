/**
 * feedback-collector.ts
 *
 * Tracks outcomes of auto-generated PRs (merged/closed/modified).
 * Adjusts pattern confidence based on results.
 * Produces weekly feedback report.
 *
 * Run: pnpm feedback
 * Cron: weekly via GitHub Actions
 */

import { execSync } from 'node:child_process';
import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { KNOWN_PROJECTS, GITHUB_OWNER } from '../factory.config.js';

interface Feedback {
  date: string;
  repo: string;
  prNumber: number;
  prTitle: string;
  outcome: 'merged' | 'closed' | 'modified' | 'open';
  patternId: string | null;
  source: 'self-heal' | 'test-scaffold' | 'prettier-fix' | 'unknown';
}

interface FeedbackLog {
  version: number;
  lastUpdated: string | null;
  feedbacks: Feedback[];
}

interface Pattern {
  id: string;
  category: string;
  signature: string;
  fix: string;
  fixType: string;
  repos_seen: string[];
  occurrences: number;
  confidence: number;
}

interface PatternDB {
  version: number;
  lastUpdated: string;
  patterns: Pattern[];
}

interface PRInfo {
  number: number;
  title: string;
  state: string;
  merged: boolean;
  labels: string[];
  createdAt: string;
  closedAt: string | null;
  mergedAt: string | null;
  commits: number;
}

const FEEDBACK_PATH = 'data/feedback-log.json';
const PATTERN_DB_PATH = 'data/patterns.json';

const sh = (cmd: string): string => {
  try {
    return execSync(cmd, { encoding: 'utf-8', timeout: 30_000 }).trim();
  } catch {
    return '';
  }
};

const loadFeedbackLog = (): FeedbackLog => {
  if (!existsSync(FEEDBACK_PATH)) return { version: 1, lastUpdated: null, feedbacks: [] };
  try {
    return JSON.parse(readFileSync(FEEDBACK_PATH, 'utf-8')) as FeedbackLog;
  } catch {
    return { version: 1, lastUpdated: null, feedbacks: [] };
  }
};

const loadPatterns = (): PatternDB => {
  if (!existsSync(PATTERN_DB_PATH)) return { version: 1, lastUpdated: '', patterns: [] };
  try {
    return JSON.parse(readFileSync(PATTERN_DB_PATH, 'utf-8')) as PatternDB;
  } catch {
    return { version: 1, lastUpdated: '', patterns: [] };
  }
};

const detectSource = (labels: string[], title: string): Feedback['source'] => {
  if (labels.includes('ai-fix') || title.includes('AI-generated')) return 'self-heal';
  if (title.includes('test scaffold') || title.includes('Test scaffold')) return 'test-scaffold';
  if (title.includes('prettier') || title.includes('Prettier')) return 'prettier-fix';
  return 'unknown';
};

const detectPatternId = (title: string, labels: string[]): string | null => {
  if (labels.includes('ai-fix')) {
    const match = title.match(/pattern:(\S+)/);
    return match ? match[1] : null;
  }
  return null;
};

const getAutoGeneratedPRs = (repo: string): PRInfo[] => {
  const result = sh(
    `gh pr list --repo ${repo} --state all --limit 20 --json number,title,state,labels,createdAt,closedAt,mergedAt,commits --jq "[.[] | select(.title | test(\\"DevOps-Factory|AI-generated|test scaffold|auto-fix|prettier\\"; \\"i\\")) | {number, title, state, merged: (.mergedAt != null), labels: [.labels[].name], createdAt, closedAt, mergedAt, commits}]"`
  );
  try {
    return JSON.parse(result || '[]') as PRInfo[];
  } catch {
    return [];
  }
};

const determinePROutcome = (pr: PRInfo): Feedback['outcome'] => {
  if (pr.merged) {
    return pr.commits > 1 ? 'modified' : 'merged';
  }
  if (pr.state === 'closed') return 'closed';
  return 'open';
};

const updatePatternConfidence = (feedback: Feedback): void => {
  if (!feedback.patternId) return;

  const db = loadPatterns();
  const pattern = db.patterns.find((p) => p.id === feedback.patternId);
  if (!pattern) return;

  switch (feedback.outcome) {
    case 'merged':
      pattern.confidence = Math.min(1, pattern.confidence + 0.1);
      break;
    case 'closed':
      pattern.confidence = Math.max(0, pattern.confidence - 0.2);
      break;
    case 'modified':
      pattern.confidence = Math.max(0, pattern.confidence - 0.05);
      break;
  }

  db.lastUpdated = new Date().toISOString();
  writeFileSync(PATTERN_DB_PATH, JSON.stringify(db, null, 2));
};

const collectFeedbacks = (): Feedback[] => {
  const log = loadFeedbackLog();
  const existingKeys = new Set(log.feedbacks.map((f) => `${f.repo}#${f.prNumber}`));
  const newFeedbacks: Feedback[] = [];

  const activeRepos = KNOWN_PROJECTS.filter((p) => p.stack !== 'unknown');

  for (const project of activeRepos) {
    console.log(`Checking ${project.name}...`);
    const prs = getAutoGeneratedPRs(project.repo);

    for (const pr of prs) {
      const key = `${project.repo}#${pr.number}`;

      if (existingKeys.has(key)) {
        // Update existing entry if outcome changed
        const existing = log.feedbacks.find(
          (f) => f.repo === project.repo && f.prNumber === pr.number
        );
        if (existing && existing.outcome === 'open') {
          const newOutcome = determinePROutcome(pr);
          if (newOutcome !== 'open') {
            existing.outcome = newOutcome;
            existing.date = new Date().toISOString();
            updatePatternConfidence(existing);
            console.log(`  Updated PR #${pr.number}: ${existing.outcome}`);
          }
        }
        continue;
      }

      const feedback: Feedback = {
        date: new Date().toISOString(),
        repo: project.repo,
        prNumber: pr.number,
        prTitle: pr.title,
        outcome: determinePROutcome(pr),
        patternId: detectPatternId(pr.title, pr.labels),
        source: detectSource(pr.labels, pr.title),
      };

      newFeedbacks.push(feedback);
      updatePatternConfidence(feedback);
      console.log(`  PR #${pr.number}: ${feedback.outcome} (${feedback.source})`);
    }
  }

  return newFeedbacks;
};

const generateReport = (log: FeedbackLog): string => {
  const recent = log.feedbacks.filter((f) => {
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    return new Date(f.date) >= weekAgo;
  });

  const merged = recent.filter((f) => f.outcome === 'merged').length;
  const closed = recent.filter((f) => f.outcome === 'closed').length;
  const modified = recent.filter((f) => f.outcome === 'modified').length;
  const open = recent.filter((f) => f.outcome === 'open').length;

  let report = `## Feedback Report (Last 7 Days)\n\n`;
  report += `| Metric | Count |\n|--------|-------|\n`;
  report += `| Merged (accepted) | ${merged} |\n`;
  report += `| Closed (rejected) | ${closed} |\n`;
  report += `| Modified before merge | ${modified} |\n`;
  report += `| Still open | ${open} |\n\n`;

  const acceptance =
    merged + modified > 0
      ? Math.round(((merged + modified) / (merged + modified + closed)) * 100)
      : 0;
  report += `**Acceptance rate**: ${acceptance}%\n\n`;

  // Top patterns
  const db = loadPatterns();
  const topPatterns = db.patterns
    .filter((p) => p.occurrences > 0)
    .sort((a, b) => b.confidence - a.confidence)
    .slice(0, 5);

  if (topPatterns.length > 0) {
    report += `### Top Patterns\n\n`;
    report += `| Pattern | Confidence | Occurrences |\n|---------|-----------|-------------|\n`;
    for (const p of topPatterns) {
      report += `| ${p.id} | ${Math.round(p.confidence * 100)}% | ${p.occurrences} |\n`;
    }
  }

  return report;
};

const main = () => {
  console.log(`\nFeedback Collector - ${new Date().toISOString()}\n`);

  const newFeedbacks = collectFeedbacks();
  const log = loadFeedbackLog();
  log.feedbacks.push(...newFeedbacks);
  log.lastUpdated = new Date().toISOString();

  writeFileSync(FEEDBACK_PATH, JSON.stringify(log, null, 2));
  console.log(`\n${newFeedbacks.length} new feedback(s) collected`);
  console.log(`Total feedbacks: ${log.feedbacks.length}`);

  const report = generateReport(log);
  console.log('\n' + report);
  writeFileSync('data/feedback-report.md', report);

  // Create GitHub issue if running in CI
  if (process.env.GITHUB_ACTIONS === 'true') {
    const factoryRepo = process.env.GITHUB_REPOSITORY ?? `${GITHUB_OWNER}/DevOps-Factory`;
    const date = new Date().toISOString().split('T')[0];
    try {
      execSync(
        `gh issue create --repo ${factoryRepo} --title "Feedback Report - ${date}" --body-file data/feedback-report.md --label "feedback-report"`,
        { encoding: 'utf-8', stdio: 'inherit' }
      );
    } catch (e) {
      console.error('Failed to create feedback issue:', e);
    }
  }
};

main();
