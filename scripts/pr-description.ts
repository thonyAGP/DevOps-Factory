/**
 * pr-description.ts
 *
 * Auto-generates PR descriptions using Claude or Gemini.
 * If PR body is empty or too short, fetches the diff and generates a description.
 * Uses same patterns as claude-review.ts and self-heal.ts.
 *
 * Run: pnpm pr-description -- --repo owner/name --pr 123
 * Trigger: GitHub Actions (on pull_request event)
 */

import { execSync } from 'node:child_process';
import { writeFileSync } from 'node:fs';

// --- Types ---

interface ParsedArgs {
  repo: string;
  pr: string;
}

interface PRInfo {
  title: string;
  body: string;
  filesChanged: number;
}

// --- Shell helpers ---

const parseArgs = (): ParsedArgs => {
  const args = process.argv.slice(2);
  let repo = '';
  let pr = '';

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--repo' && args[i + 1]) repo = args[i + 1];
    if (args[i] === '--pr' && args[i + 1]) pr = args[i + 1];
  }

  if (!repo || !pr) {
    console.error('Usage: tsx scripts/pr-description.ts --repo owner/name --pr 123');
    process.exit(1);
  }

  return { repo, pr };
};

const sh = (cmd: string): string => {
  try {
    return execSync(cmd, { encoding: 'utf-8', maxBuffer: 10 * 1024 * 1024 }).trim();
  } catch (e: unknown) {
    const err = e as { stdout?: string; stderr?: string };
    return err.stdout?.trim() || err.stderr?.trim() || '';
  }
};

const ghApi = <T>(endpoint: string): T | null => {
  const raw = sh(`gh api "${endpoint}"`);
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
};

// --- PR data fetching ---

const getPRDiff = (repo: string, pr: string): string => {
  return sh(`gh pr diff ${pr} --repo ${repo}`);
};

const getPRInfo = (repo: string, pr: string): PRInfo => {
  const data = ghApi<{
    title: string;
    body: string;
    changed_files: number;
  }>(`repos/${repo}/pulls/${pr}`);

  return {
    title: data?.title || 'Unknown PR',
    body: data?.body || '',
    filesChanged: data?.changed_files || 0,
  };
};

// --- PR description generation ---

const buildDescriptionPrompt = (diff: string, prInfo: PRInfo): string => {
  return `You are an expert technical writer. Generate a concise and professional PR description based on this diff.

Focus on:
1. Summary of changes (2-3 sentences explaining the main purpose)
2. Key changes (bulleted list of important modifications)
3. Potential impact (what parts of the codebase are affected)
4. Testing suggestions (how to verify these changes work correctly)

Format as markdown with clear sections. Be concise but comprehensive.

---

**PR Title**: ${prInfo.title}
**Files Changed**: ${prInfo.filesChanged}

## Diff
\`\`\`diff
${diff.slice(0, 40000)}
\`\`\``;
};

const GEMINI_MODEL = 'gemini-2.5-flash';
const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;

const generateDescription = (diff: string, prInfo: PRInfo): string => {
  const prompt = buildDescriptionPrompt(diff, prInfo);

  // Try Claude CLI first (works locally with Max plan tokens)
  try {
    const result = execSync('claude -p --output-format text', {
      input: prompt,
      encoding: 'utf-8',
      timeout: 300_000,
      maxBuffer: 10 * 1024 * 1024,
    });
    return result.trim() + '\n\n---\n*Generated by Claude (Max plan)*';
  } catch {
    console.log('  Claude CLI unavailable, trying Gemini fallback...');
  }

  // Fallback: Gemini API (works in CI with API key)
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    return `## PR Description\n\n> Description generation unavailable: no Claude CLI or GEMINI_API_KEY.\n\nPlease fill in the PR description manually.\n\n**Files changed**: ${prInfo.filesChanged}`;
  }

  try {
    const body = JSON.stringify({
      contents: [{ parts: [{ text: prompt }] }],
      generationConfig: { maxOutputTokens: 2048, temperature: 0.3 },
    });
    const result = execSync(
      `curl -s -X POST "${GEMINI_URL}?key=${apiKey}" -H "Content-Type: application/json" -d @-`,
      { input: body, encoding: 'utf-8', timeout: 60000, maxBuffer: 10 * 1024 * 1024 }
    );
    const parsed = JSON.parse(result);
    const text = parsed?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (text) return text + '\n\n---\n*Generated by Gemini 2.5 Flash*';
  } catch (e) {
    console.error('Gemini generation error:', e instanceof Error ? e.message : String(e));
  }

  return `## PR Description\n\n> Description generation failed. Please fill in the PR description manually.\n\nFiles changed: ${prInfo.filesChanged}`;
};

// --- Posting description ---

const postDescriptionComment = (repo: string, pr: string, description: string): void => {
  const tmpFile = '/tmp/pr-description-body.md';
  writeFileSync(tmpFile, description);
  sh(`gh pr comment ${pr} --repo ${repo} --body-file ${tmpFile}`);
};

// --- Main ---

const main = async (): Promise<void> => {
  const { repo, pr } = parseArgs();
  console.log(`\nðŸ“ PR Description Generator for ${repo} #${pr}\n`);

  // Get PR info
  console.log('Fetching PR info...');
  const prInfo = getPRInfo(repo, pr);
  console.log(`  Title: ${prInfo.title}`);
  console.log(`  Files: ${prInfo.filesChanged}`);
  console.log(`  Body length: ${prInfo.body.length} chars`);

  // Check if description needs generation
  if (prInfo.body && prInfo.body.length >= 50) {
    console.log('âœ“ PR already has a description. Skipping generation.');
    return;
  }

  // Get diff
  console.log('Fetching PR diff...');
  const diff = getPRDiff(repo, pr);
  if (!diff) {
    console.log('  No diff found (possibly merged or deleted PR)');
    return;
  }
  console.log(`  Diff size: ${Math.round(diff.length / 1024)}KB`);

  // Generate description
  console.log('Generating description...');
  const description = generateDescription(diff, prInfo);

  // Post comment
  console.log('Posting description comment...');
  postDescriptionComment(repo, pr, description);

  console.log('\nâœ… Description posted\n');
};

main().catch((err) => {
  console.error(
    'PR description generation failed:',
    err instanceof Error ? err.message : String(err)
  );
  process.exit(1);
});
