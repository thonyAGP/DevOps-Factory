/**
 * auto-fix-prettier.ts
 *
 * Clones all Node-based repos, runs Prettier, creates PRs for any formatting fixes.
 * Skips repos without Prettier config or without formatting issues.
 *
 * Run: pnpm fix-prettier
 * Cron: weekly (Monday 8am) via GitHub Actions
 */

import { execSync } from 'node:child_process';
import { existsSync, mkdirSync, rmSync } from 'node:fs';
import { KNOWN_PROJECTS, GITHUB_OWNER, type ProjectConfig } from '../factory.config.js';

const BRANCH_NAME = 'devops-factory/prettier-fix';
const LABEL = 'prettier-fix';
const WORK_DIR = '/tmp/prettier-fixes';

const NODE_STACKS = new Set(['nextjs', 'fastify', 'node', 'astro']);

const sh = (cmd: string, cwd?: string): string => {
  try {
    return execSync(cmd, { encoding: 'utf-8', cwd, timeout: 120000, stdio: 'pipe' }).trim();
  } catch {
    return '';
  }
};

const shOrFail = (cmd: string, cwd?: string): string => {
  return execSync(cmd, { encoding: 'utf-8', cwd, timeout: 120000, stdio: 'pipe' }).trim();
};

const hasPrettierConfig = (dir: string): boolean => {
  const configs = [
    '.prettierrc',
    '.prettierrc.json',
    '.prettierrc.yml',
    '.prettierrc.js',
    'prettier.config.js',
    'prettier.config.mjs',
  ];
  return configs.some((f) => existsSync(`${dir}/${f}`));
};

const getPackageManager = (dir: string): 'pnpm' | 'npm' | 'yarn' => {
  if (existsSync(`${dir}/pnpm-lock.yaml`)) return 'pnpm';
  if (existsSync(`${dir}/yarn.lock`)) return 'yarn';
  return 'npm';
};

const getDefaultBranch = (repo: string): string => {
  return sh(`gh api "repos/${repo}" --jq ".default_branch"`) || 'main';
};

const branchExists = (repo: string): boolean => {
  const result = sh(`gh api "repos/${repo}/branches/${BRANCH_NAME}" --jq ".name" 2>&1`);
  return result === BRANCH_NAME;
};

const prExists = (repo: string): boolean => {
  const result = sh(
    `gh pr list --repo ${repo} --head ${BRANCH_NAME} --json number --jq ".[0].number"`
  );
  return !!result;
};

const installDeps = (dir: string, pm: 'pnpm' | 'npm' | 'yarn'): boolean => {
  try {
    const cmd =
      pm === 'pnpm'
        ? 'pnpm install --frozen-lockfile --ignore-scripts'
        : pm === 'yarn'
          ? 'yarn install --frozen-lockfile --ignore-scripts'
          : 'npm ci --ignore-scripts';
    execSync(cmd, { cwd: dir, timeout: 120000, stdio: 'pipe' });
    return true;
  } catch {
    // Fallback without frozen lockfile
    try {
      const cmd =
        pm === 'pnpm'
          ? 'pnpm install --ignore-scripts'
          : pm === 'yarn'
            ? 'yarn install --ignore-scripts'
            : 'npm install --ignore-scripts';
      execSync(cmd, { cwd: dir, timeout: 120000, stdio: 'pipe' });
      return true;
    } catch {
      return false;
    }
  }
};

const runPrettierCheck = (dir: string): string[] => {
  try {
    execSync(`npx prettier --check "**/*.{ts,tsx,js,jsx,json,css,md,yml,yaml}" --ignore-unknown`, {
      cwd: dir,
      timeout: 60000,
      stdio: 'pipe',
    });
    return [];
  } catch (e: unknown) {
    const err = e as { stdout?: Buffer; stderr?: Buffer };
    const output = (err.stdout?.toString() || '') + (err.stderr?.toString() || '');
    return output
      .split('\n')
      .filter((l) => l.startsWith('[warn]') || l.includes('would be reformatted'))
      .slice(0, 50);
  }
};

const runPrettierWrite = (dir: string): void => {
  execSync(`npx prettier --write "**/*.{ts,tsx,js,jsx,json,css,md,yml,yaml}" --ignore-unknown`, {
    cwd: dir,
    timeout: 60000,
    stdio: 'pipe',
  });
};

const getChangedFileCount = (dir: string): number => {
  const output = sh('git diff --name-only', dir);
  if (!output) return 0;
  return output.split('\n').filter(Boolean).length;
};

const createPR = (repo: string, dir: string, defaultBranch: string, fileCount: number): void => {
  // Configure git
  shOrFail('git config user.name "DevOps Factory Bot"', dir);
  shOrFail('git config user.email "devops-factory[bot]@users.noreply.github.com"', dir);

  // Delete remote branch if exists (stale from previous run)
  if (branchExists(repo)) {
    sh(`gh api "repos/${repo}/git/refs/heads/${BRANCH_NAME}" --method DELETE`, dir);
  }

  // Create branch, commit, push
  shOrFail(`git checkout -b ${BRANCH_NAME}`, dir);
  shOrFail('git add -A', dir);
  shOrFail(
    `git commit -m "style: auto-fix formatting with Prettier\n\nFormatted ${fileCount} file(s) via DevOps Factory."`,
    dir
  );
  shOrFail(`git push origin ${BRANCH_NAME}`, dir);

  // Create PR
  const body = [
    '## Prettier Formatting Fix',
    '',
    `This PR fixes formatting in **${fileCount} file(s)** using Prettier.`,
    '',
    'Auto-generated by [DevOps Factory](https://github.com/thonyAGP/DevOps-Factory) CI Health pipeline.',
    '',
    '---',
    '*Merge this PR to keep code formatting consistent. No functional changes.*',
  ].join('\n');

  shOrFail(
    `gh pr create --repo ${repo} --head ${BRANCH_NAME} --base ${defaultBranch} --title "style: auto-fix Prettier formatting" --body "${body}" --label "${LABEL}"`,
    dir
  );
};

interface FixResult {
  project: string;
  status: 'fixed' | 'clean' | 'skipped' | 'error';
  fileCount: number;
  reason?: string;
}

const processRepo = (project: ProjectConfig): FixResult => {
  const repoDir = `${WORK_DIR}/${project.name}`;

  try {
    // Clone shallow
    shOrFail(`gh repo clone ${project.repo} "${repoDir}" -- --depth 1`, WORK_DIR);

    // Check for prettier config
    if (!hasPrettierConfig(repoDir)) {
      return {
        project: project.name,
        status: 'skipped',
        fileCount: 0,
        reason: 'no prettier config',
      };
    }

    // Check if PR already exists
    if (prExists(project.repo)) {
      return {
        project: project.name,
        status: 'skipped',
        fileCount: 0,
        reason: 'PR already open',
      };
    }

    // Install deps
    const pm = getPackageManager(repoDir);
    if (!installDeps(repoDir, pm)) {
      return { project: project.name, status: 'error', fileCount: 0, reason: 'install failed' };
    }

    // Check formatting
    const issues = runPrettierCheck(repoDir);
    if (issues.length === 0) {
      return { project: project.name, status: 'clean', fileCount: 0 };
    }

    // Fix formatting
    runPrettierWrite(repoDir);
    const fileCount = getChangedFileCount(repoDir);

    if (fileCount === 0) {
      return { project: project.name, status: 'clean', fileCount: 0 };
    }

    // Create PR
    const defaultBranch = getDefaultBranch(project.repo);
    createPR(project.repo, repoDir, defaultBranch, fileCount);

    return { project: project.name, status: 'fixed', fileCount };
  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : String(e);
    return { project: project.name, status: 'error', fileCount: 0, reason: msg.slice(0, 200) };
  } finally {
    // Cleanup
    if (existsSync(repoDir)) {
      rmSync(repoDir, { recursive: true, force: true });
    }
  }
};

const main = () => {
  console.log(`\nPrettier Auto-Fix - ${new Date().toISOString()}`);

  const nodeProjects = KNOWN_PROJECTS.filter((p) => NODE_STACKS.has(p.stack));
  console.log(`Found ${nodeProjects.length} Node-based repos to check\n`);

  // Ensure label exists
  sh(
    `gh label create "${LABEL}" --repo ${GITHUB_OWNER}/DevOps-Factory --color 1d76db --description "Auto-generated Prettier formatting fix" 2>/dev/null`
  );

  // Prepare work directory
  if (existsSync(WORK_DIR)) {
    rmSync(WORK_DIR, { recursive: true, force: true });
  }
  mkdirSync(WORK_DIR, { recursive: true });

  const results: FixResult[] = [];

  for (const project of nodeProjects) {
    process.stdout.write(`[${project.name}] `);
    const result = processRepo(project);
    results.push(result);

    switch (result.status) {
      case 'fixed':
        console.log(`FIXED (${result.fileCount} files) - PR created`);
        break;
      case 'clean':
        console.log('CLEAN');
        break;
      case 'skipped':
        console.log(`SKIPPED (${result.reason})`);
        break;
      case 'error':
        console.log(`ERROR (${result.reason})`);
        break;
    }
  }

  // Summary
  const fixed = results.filter((r) => r.status === 'fixed');
  const clean = results.filter((r) => r.status === 'clean');
  const skipped = results.filter((r) => r.status === 'skipped');
  const errors = results.filter((r) => r.status === 'error');

  console.log('\n--- Summary ---');
  console.log(`Fixed:   ${fixed.length} (PRs created)`);
  console.log(`Clean:   ${clean.length}`);
  console.log(`Skipped: ${skipped.length}`);
  if (errors.length > 0) console.log(`Errors:  ${errors.length}`);
  console.log('');

  // Cleanup
  if (existsSync(WORK_DIR)) {
    rmSync(WORK_DIR, { recursive: true, force: true });
  }
};

main();
